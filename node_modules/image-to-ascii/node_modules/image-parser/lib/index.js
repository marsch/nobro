"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var lwipify = require("lwipify"),
    gmTools = require("gm-tools"),
    CbBuffer = require("cb-buffer"),
    Err = require("err"),
    Pixel = require("pixel-class");

module.exports = function () {
    /**
     * ImageParser
     * Creates a new instance of `ImageParser`.
     *
     * @name ImageParser
     * @function
     * @param {String|Buffer} source The image path/url or the a `Buffer` object.
     * @param {Object} options The options object to pass to the `lwipify`.
     * @return {ImageParser} The `ImageParser` instance.
     */

    function ImageParser(source, options) {
        _classCallCheck(this, ImageParser);

        this.source = source;
        this.options = options;
        this.parser = null;
        this.gm = false;
        this.lwip = false;
        this.img = null;
        this._parseBuffer = new CbBuffer();
        this.__lwip = true;
    }

    /**
     * parse
     * Prepare the in-memory data (image pixels, buffers, size etc).
     *
     * @name parse
     * @function
     * @param {Function} cb The callback function.
     */


    _createClass(ImageParser, [{
        key: "parse",
        value: function parse(cb) {
            var _this = this;

            if (this._parseBuffer.check(cb)) {
                return;
            }
            lwipify(this.source, this.options, function (err, data, options) {
                if (err) {
                    //if (err.message === "Invalid PNG buffer" || err.message === "Invalid source" || /Unknown type/.test(err.message)) {
                    _this[_this.parser = "gm"] = true;
                    _this.img = gmTools(options.source);
                    return _this.img.parse(function (err, data) {
                        if (!err) {
                            _this._imgBuffer = data[0];
                        }
                        return _this._parseBuffer.done(err, _this, data);
                    });
                    //}
                    //return this._parseBuffer.done(err);
                }
                _this.img = data;
                _this[_this.parser = "lwip"] = true;
                _this._parseBuffer.done(null, _this, data);
            });
        }

        /*!
         * _checkParsed
         * This method throws an error if the image was *not* parsed.
         *
         * @name _checkParsed
         * @function
         */

    }, {
        key: "_checkParsed",
        value: function _checkParsed() {
            if (!this.img) {
                throw new Err("Parse the image first by using the parse method.", "IMAGE_NOT_PARSED");
            }
        }

        /**
         * width
         * Returns the image width.
         *
         * @name width
         * @function
         * @returns {Number} The image width.
         */

    }, {
        key: "width",
        value: function width() {
            this._checkParsed();
            return this.img.width();
        }

        /**
         * height
         * Returns the image height.
         *
         * @name height
         * @function
         * @returns {Number} The image height.
         */

    }, {
        key: "height",
        value: function height() {
            this._checkParsed();
            return this.img.height();
        }

        /**
         * getPixel
         * Gets the pixel at given coordinates.
         *
         * @name getPixel
         * @function
         * @param {Number} x The `x` coordinate.
         * @param {Number} y The `y` coordinate.
         * @returns {Pixel} The [`Pixel`](https://github.com/IonicaBizau/pixel-class) instance containing the pixel data.
         */

    }, {
        key: "getPixel",
        value: function getPixel(x, y) {
            this._checkParsed();
            var args = [x, y];
            this.gm ? args.push(this._imgBuffer) : "";
            return new Pixel(this.img.getPixel.apply(this.img, args));
        }

        /**
         * pixels
         * Gets the image pixels.
         *
         * @name pixels
         * @function
         * @returns {Array} An array of [`Pixel`](https://github.com/IonicaBizau/pixel-class) objects containing the pixel information.
         */

    }, {
        key: "pixels",
        value: function (_pixels) {
            function pixels() {
                return _pixels.apply(this, arguments);
            }

            pixels.toString = function () {
                return _pixels.toString();
            };

            return pixels;
        }(function () {
            this._checkParsed();
            if (this.gm) {
                return this.img.pixels(this._parseBuffer);
            }

            var size = {
                height: this.height(),
                width: this.width()
            };

            for (var y = 0; y < size.height; ++y) {
                for (var x = 0; x < size.width; ++x) {
                    pixels.push(this.getPixel(x, y));
                }
            }

            return pixels;
        })

        /**
         * resize
         * Resizes the image.
         *
         * @name resize
         * @function
         * @param {Number} width The new image width.
         * @param {Number} height The new image height.
         * @param {Function} cb The callback function.
         */

    }, {
        key: "resize",
        value: function resize(width, height, cb) {
            var _this2 = this;

            this._checkParsed();
            if (this.gm) {
                this.img.resize(width, height, "!");
                this.img.gm.toBuffer("PNG", function (err, data) {
                    var resized = new ImageParser(data, _this2.options);
                    resized.parse(function (err) {
                        return cb(err, resized);
                    });
                });
            } else {
                this.img.resize(width, height, function (err, img) {
                    var resized = new ImageParser(img, _this2.options);
                    resized.parse(function (err) {
                        return cb(err, resized);
                    });
                });
            }
        }
    }]);

    return ImageParser;
}();